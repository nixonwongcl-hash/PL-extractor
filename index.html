<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>PL Code Scanner</title>

    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/tesseract.js@v4.0.2/dist/tesseract.min.js"></script>
    <script src="https://unpkg.com/@ericblade/quagga2@1.2.6/dist/quagga.min.js"></script>

    <style>
      * {
        box-sizing: border-box;
      }

      body {
        font-family: Inter, system-ui, -apple-system, sans-serif;
        background: #f8fafc;
        margin: 0;
        padding: 0;
        line-height: 1.5;
      }

      .container {
        max-width: 100vw;
        padding: 12px;
      }

      /* Mobile-first cards */
      .card {
        background: #fff;
        border-radius: 16px;
        padding: 16px;
        margin-bottom: 16px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .card h2 {
        margin: 0 0 16px 0;
        font-size: 1.25rem;
        font-weight: 600;
        color: #1a202c;
      }

      /* Large mobile-friendly buttons */
      .btn {
        background: #3182ce;
        color: #fff;
        border: 0;
        padding: 14px 20px;
        border-radius: 12px;
        font-weight: 600;
        font-size: 16px;
        cursor: pointer;
        min-height: 48px;
        width: 100%;
        margin-bottom: 8px;
        transition: background 0.2s;
      }

      .btn:active {
        background: #2c5aa0;
        transform: scale(0.98);
      }

      .btn:disabled {
        background: #a0aec0;
        cursor: not-allowed;
        transform: none;
      }

      .btn-secondary {
        background: #718096;
      }

      .btn-secondary:active {
        background: #4a5568;
      }

      .btn-danger {
        background: #e53e3e;
      }

      .btn-danger:active {
        background: #c53030;
      }

      /* Mobile file input */
      .file-input-wrapper {
        position: relative;
        overflow: hidden;
        display: block;
        margin-bottom: 12px;
      }

      .file-input-wrapper input[type="file"] {
        position: absolute;
        left: -9999px;
      }

      .file-input-label {
        display: block;
        padding: 16px;
        background: #f7fafc;
        border: 2px dashed #cbd5e0;
        border-radius: 12px;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s;
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
      }

      .file-input-label:active {
        background: #edf2f7;
        border-color: #a0aec0;
      }

      /* Status messages */
      .status {
        padding: 12px 16px;
        border-radius: 8px;
        font-weight: 500;
        margin: 8px 0;
        text-align: center;
      }

      .status.info {
        background: #ebf8ff;
        color: #2c5aa0;
      }
      .status.success {
        background: #f0fff4;
        color: #2f855a;
      }
      .status.error {
        background: #fed7d7;
        color: #c53030;
      }
      .status.warning {
        background: #fffbeb;
        color: #d69e2e;
      }

      /* Video optimized for mobile */
      /* Make scanner full screen inside the card */
.video-container {
  position: relative;
  background: #000;
  border-radius: 12px;
  overflow: hidden;
  margin: 12px 0;
  width: 100%;
  height: 70vh; /* fill most of the viewport height */
}

#video {
  width: 100%;
  height: 100%;
  object-fit: cover; /* fill and crop without distortion */
  display: block;
}

.video-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  border: 2px solid #fff;
  border-radius: 8px;
  width: 60%;
  height: 30%;
  pointer-events: none;
  opacity: 0.7;
}

      /* Counter optimized for mobile */
      .counter {
        display: block;
        padding: 16px;
        border-radius: 12px;
        font-weight: 700;
        font-size: 18px;
        text-align: center;
        margin-bottom: 16px;
      }

      .counter.pending {
        background: #fed7d7;
        color: #c53030;
        border: 2px solid #feb2b2;
      }

      .counter.success {
        background: #c6f6d5;
        color: #2f855a;
        border: 2px solid #9ae6b4;
      }

      /* Mobile-optimized table */
      .table-container {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
        background: #fff;
      }

      .scroll-indicator {
        text-align: center;
        font-size: 12px;
        color: #718096;
        padding: 4px;
        background: #f7fafc;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        min-width: 400px;
      }

      thead th {
        background: #f7fafc;
        color: #2d3748;
        padding: 12px 8px;
        border-bottom: 2px solid #e2e8f0;
        text-align: left;
        font-weight: 600;
        font-size: 14px;
        position: sticky;
        top: 0;
      }

      tbody td {
        padding: 14px 8px;
        border-bottom: 1px solid #f1f5f9;
        font-size: 14px;
      }

      .scanned {
        background: #f0fff4 !important;
      }

      .flash-success {
        background: #c6f6d5 !important;
        animation: flash 0.5s ease;
      }

      .flash-warning {
        background: #fefcbf !important;
        animation: flash 0.5s ease;
      }

      .flash-error {
        background: #fed7d7 !important;
        animation: flash 0.5s ease;
      }

      @keyframes flash {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      .total-row td {
        font-weight: 700;
        background: #f7fafc;
        border-top: 2px solid #e2e8f0;
      }

      /* Mobile checkboxes */
      input[type="checkbox"] {
        width: 20px;
        height: 20px;
        cursor: pointer;
      }

      /* Camera controls */
      .camera-controls {
        display: flex;
        gap: 8px;
        margin: 12px 0;
      }

      .camera-controls button {
        flex: 1;
        margin-bottom: 0;
      }

      /* Last scan display */
      .last-scan {
        background: #f7fafc;
        padding: 12px;
        border-radius: 8px;
        margin: 8px 0;
        font-family: monospace;
        font-size: 14px;
        word-break: break-all;
        border-left: 4px solid #3182ce;
      }

      /* Progress indicator */
      .progress {
        width: 100%;
        height: 4px;
        background: #e2e8f0;
        border-radius: 2px;
        overflow: hidden;
        margin: 8px 0;
      }

      .progress-bar {
        height: 100%;
        background: #3182ce;
        border-radius: 2px;
        transition: width 0.3s ease;
        width: 0%;
      }

      /* Responsive adjustments */
      @media (min-width: 640px) {
        .container {
          padding: 20px;
        }
        .card {
          padding: 24px;
        }

        .btn-row {
          display: flex;
          gap: 12px;
        }

        .btn-row .btn {
          margin-bottom: 0;
        }
      }

      /* Hide elements when not needed */
      .hidden {
        display: none;
      }

      /* Haptic feedback simulation */
      .haptic {
        animation: haptic 0.1s ease;
      }

      /* Tabs styling */
      .tabs {
        display: flex;
        background: #f7fafc;
        border-radius: 12px;
        padding: 4px;
        margin-bottom: 16px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      .tab {
        flex: 1;
        min-width: 100px;
        padding: 12px 8px;
        text-align: center;
        background: transparent;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
      }

      .tab.active {
        background: #3182ce;
        color: #fff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .tab:not(.active) {
        color: #4a5568;
      }

      .tab:not(.active):active {
        background: #edf2f7;
      }

      .tab-badge {
        display: inline-block;
        background: rgba(255, 255, 255, 0.2);
        color: inherit;
        padding: 2px 6px;
        border-radius: 10px;
        font-size: 12px;
        font-weight: 700;
        margin-left: 4px;
      }

      .tab:not(.active) .tab-badge {
        background: #e2e8f0;
        color: #4a5568;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- File Upload Section -->
      <div class="card">
        <h2>üìÑ Upload Files</h2>

        <div class="file-input-wrapper">
          <input
            id="fileInput"
            type="file"
            accept="application/pdf,image/*"
            multiple
          />
          <label for="fileInput" class="file-input-label">
            <span id="fileLabel">üìÅ Tap to select PDF or image files</span>
          </label>
        </div>

        <button id="extractBtn" class="btn">üîç Extract PL Codes</button>

        <div class="progress hidden" id="extractProgress">
          <div class="progress-bar" id="extractProgressBar"></div>
        </div>

        <div id="extractStatus"></div>
      </div>

      <!-- Scanner Section -->
      <div class="card">
        <h2>üì± Camera Scanner</h2>

        <div class="camera-controls btn-row">
          <button id="startScanBtn" class="btn" disabled>
            üì∑ Start Scanner
          </button>
          <button id="switchCameraBtn" class="btn btn-secondary hidden">
            üîÑ Switch
          </button>
        </div>

        <div class="camera-controls btn-row">
          <button id="stopScanBtn" class="btn btn-danger" disabled>
            ‚èπ Stop
          </button>
          <button id="clearBtn" class="btn btn-secondary" disabled>
            üßπ Clear All
          </button>
        </div>

        <div class="video-container hidden" id="videoContainer">
          <video id="video" playsinline muted></video>
          <div class="video-overlay"></div>
        </div>

        <div id="scanStatus" class="status info">
          Scanner ready - upload files first
        </div>
        <div id="lastScan" class="last-scan hidden"></div>
      </div>

      <!-- Results Section -->
      <div class="card">
        <div id="counter" class="counter pending">No codes loaded</div>

        <!-- Tabs -->
        <div class="tabs">
          <button class="tab active" data-tab="all">
            üìã All PLs <span class="tab-badge" id="allCount">0</span>
          </button>
          <button class="tab" data-tab="unmatched">
            ‚ùå Unmatched <span class="tab-badge" id="unmatchedCount">0</span>
          </button>
          <button class="tab" data-tab="completed">
            ‚úÖ Completed <span class="tab-badge" id="completedCount">0</span>
          </button>
        </div>

        <div class="table-container">
          <div class="scroll-indicator">‚Üê Swipe to see all columns ‚Üí</div>
          <table id="plTable" aria-label="PL codes table">
            <thead>
              <tr>
                <th style="width: 50px">#</th>
                <th style="width: 50px; text-align: center">‚úì</th>
                <th style="width: 140px">PL Code</th>
                <th>Status / Progress</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td
                  colspan="4"
                  style="text-align: center; padding: 40px; color: #718096"
                >
                  Upload files to see PL codes here
                </td>
              </tr>
            </tbody>
            <tfoot>
              <tr class="total-row">
                <td colspan="4" id="totalCell">Total: 0 codes</td>
              </tr>
            </tfoot>
          </table>
        </div>
      </div>

      <!-- Instructions -->
      <div class="card">
        <h2>üìã Instructions</h2>
        <ul>
          <li>
            <strong>Step 1:</strong> Upload PDF files or images containing PL
            codes
          </li>
          <li><strong>Step 2:</strong> Start the camera scanner</li>
          <li>
            <strong>Step 3:</strong> Point camera at PL codes to mark them as
            scanned
          </li>
          <li>
            <strong>Tip:</strong> Hold steady and ensure good lighting for best
            results
          </li>
        </ul>
      </div>
    </div>

    <script>
      // Configuration
      const PL_CANON = /^P\d{2}[A-Z]{2}\d{7}$/;
      const PL_FLEX_GLOBAL = /P\s*\d{2}\s*[A-Za-z]{2}\s*\d{6,8}/gi;
      const PL_FLEX = /P\s*\d{2}\s*[A-Za-z]{2}\s*\d{6,8}/i;
      const PL_X_MIN = 700;
      const PL_X_MAX = 790;

      // Elements
      const fileInput = document.getElementById("fileInput");
      const fileLabel = document.getElementById("fileLabel");
      const extractBtn = document.getElementById("extractBtn");
      const extractStatus = document.getElementById("extractStatus");
      const extractProgress = document.getElementById("extractProgress");
      const extractProgressBar = document.getElementById("extractProgressBar");

      const startScanBtn = document.getElementById("startScanBtn");
      const stopScanBtn = document.getElementById("stopScanBtn");
      const switchCameraBtn = document.getElementById("switchCameraBtn");
      const clearBtn = document.getElementById("clearBtn");
      const scanStatus = document.getElementById("scanStatus");
      const lastScan = document.getElementById("lastScan");
      const videoEl = document.getElementById("video");
      const videoContainer = document.getElementById("videoContainer");

      const tableBody = document.querySelector("#plTable tbody");
      const totalCell = document.getElementById("totalCell");
      const counterEl = document.getElementById("counter");

      // Tab elements
      const tabButtons = document.querySelectorAll(".tab");
      const allCountEl = document.getElementById("allCount");
      const unmatchedCountEl = document.getElementById("unmatchedCount");
      const completedCountEl = document.getElementById("completedCount");

      // State
      let uniquePLs = [];
      let plRowMap = new Map();
      let scannedSet = new Set();
      let scannedCount = 0;
      let codeReader = null;
      let availableCameras = [];
      let currentCameraIndex = 0;
      let activeTab = "all"; // 'all', 'unmatched', 'completed'

      // Utility functions
      const normalize = (s) =>
        (s || "")
          .toString()
          .replace(/[^A-Za-z0-9]/g, "")
          .toUpperCase();

      function showStatus(element, message, type = "info") {
        element.className = `status ${type}`;
        element.textContent = message;
        element.style.display = "block";
      }

      function triggerHaptic(element) {
        if ("vibrate" in navigator) {
          navigator.vibrate(50);
        }
        element.classList.add("haptic");
        setTimeout(() => element.classList.remove("haptic"), 100);
      }

      function updateProgress(percent) {
        extractProgressBar.style.width = `${percent}%`;
      }

      function updateCounter() {
        const total = uniquePLs.length;
        const done = scannedCount >= total && total > 0;

        if (total === 0) {
          counterEl.textContent = "No codes loaded";
          counterEl.className = "counter pending";
        } else if (done) {
          counterEl.textContent = `‚úÖ All ${total} codes scanned!`;
          counterEl.className = "counter success";
          triggerHaptic(counterEl);
        } else {
          counterEl.textContent = `${scannedCount} / ${total} codes scanned`;
          counterEl.className = "counter pending";
        }
      }

      function updateTabCounts() {
        const total = uniquePLs.length;
        const completed = scannedCount;
        const unmatched = total - completed;

        allCountEl.textContent = total;
        completedCountEl.textContent = completed;
        unmatchedCountEl.textContent = unmatched;
      }

      function groupByMPL(pls) {
        const groups = {};
        pls.forEach((pl) => {
          const mpl = pl.substring(0, 6); // P12AB format
          if (!groups[mpl]) groups[mpl] = [];
          groups[mpl].push(pl);
        });
        return groups;
      }

      function updateMPLProgress(mpl) {
        // This function can be expanded later for MPL-specific progress tracking
        console.log(`MPL ${mpl} progress updated`);
      }

      function renderTable() {
        tableBody.innerHTML = "";
        plRowMap.clear();

        if (uniquePLs.length === 0) {
          const emptyRow = document.createElement("tr");
          emptyRow.innerHTML =
            '<td colspan="4" style="text-align: center; padding: 40px; color: #718096;">Upload files to see PL codes here</td>';
          tableBody.appendChild(emptyRow);
          totalCell.textContent = "Total: 0 codes";
          return;
        }

        // Filter based on active tab
        let filteredPLs = uniquePLs;
        if (activeTab === "completed") {
          filteredPLs = uniquePLs.filter((pl) => scannedSet.has(normalize(pl)));
        } else if (activeTab === "unmatched") {
          filteredPLs = uniquePLs.filter(
            (pl) => !scannedSet.has(normalize(pl))
          );
        }

        filteredPLs.forEach((pl, i) => {
          const tr = document.createElement("tr");
          const isScanned = scannedSet.has(normalize(pl));
          tr.innerHTML = `
          <td style="text-align: center; font-weight: 600;">${i + 1}</td>
          <td style="text-align: center;">
            <input type="checkbox" style="transform: scale(1.2);" ${
              isScanned ? "checked" : ""
            }>
          </td>
          <td style="font-family: monospace; font-weight: 600;">${pl}</td>
          <td class="remark-cell">${
            isScanned ? "‚úÖ Scanned" : "Ready to scan"
          }</td>
        `;

          if (isScanned) {
            tr.classList.add("scanned");
          }

          tableBody.appendChild(tr);
          const checkbox = tr.querySelector('input[type="checkbox"]');
          const remarkCell = tr.querySelector(".remark-cell");

          plRowMap.set(normalize(pl), { row: tr, checkbox, remarkCell });
        });

        totalCell.textContent = `Total: ${filteredPLs.length} codes`;

        // Update button states
        startScanBtn.disabled = uniquePLs.length === 0;
        clearBtn.disabled = uniquePLs.length === 0;

        if (uniquePLs.length > 0) {
          showStatus(
            scanStatus,
            "üì∑ Ready to scan - tap Start Scanner",
            "success"
          );
        }
      }

      function flashRow(row, type = "success") {
        row.classList.add(`flash-${type}`);
        setTimeout(() => {
          row.classList.remove(`flash-${type}`);
        }, 500);
      }

      function onScanMatch(rawCode) {
        const code = normalize(rawCode);
        lastScan.textContent = `Last: ${code || rawCode}`;
        lastScan.classList.remove("hidden");

        // Find PL pattern in scanned code
        PL_FLEX_GLOBAL.lastIndex = 0;
        const matches = [...(rawCode.match(PL_FLEX_GLOBAL) || [])];
        let candidate = null;

        if (matches.length) {
          candidate = normalize(matches[0]);
        } else if (PL_CANON.test(code)) {
          candidate = code;
        }

        if (!candidate) {
          showStatus(
            scanStatus,
            `‚ùå No PL pattern found in: ${rawCode}`,
            "error"
          );
          document.querySelector("#plTable").classList.add("flash-error");
          setTimeout(
            () =>
              document
                .querySelector("#plTable")
                .classList.remove("flash-error"),
            300
          );
          return;
        }

        const entry = plRowMap.get(candidate);
        if (!entry) {
          showStatus(
            scanStatus,
            `‚ùå Code not in list: ${candidate}`,
            "warning"
          );
          document.querySelector("#plTable").classList.add("flash-warning");
          setTimeout(
            () =>
              document
                .querySelector("#plTable")
                .classList.remove("flash-warning"),
            300
          );
          return;
        }

        if (scannedSet.has(candidate)) {
          entry.remarkCell.textContent = `‚úÖ Already scanned (${new Date().toLocaleTimeString()})`;
          showStatus(scanStatus, `‚ö† Already scanned: ${candidate}`, "warning");
          flashRow(entry.row, "warning");
          return;
        }

        // Mark as scanned
        scannedSet.add(candidate);
        entry.checkbox.checked = true;
        entry.row.classList.add("scanned");
        entry.remarkCell.textContent = `‚úÖ Scanned at ${new Date().toLocaleTimeString()}`;
        flashRow(entry.row, "success");
        scannedCount++;

        updateCounter();
        updateTabCounts();

        // Auto-switch to unmatched tab if current item was removed from view
        if (activeTab === "unmatched") {
          renderTable(); // Refresh to remove completed items
        }

        showStatus(scanStatus, `‚úÖ Matched: ${candidate}`, "success");
        triggerHaptic(document.body);
      }

      // File handling
      fileInput.addEventListener("change", (e) => {
        const files = e.target.files;
        if (files.length === 0) {
          fileLabel.textContent = "üìÅ Tap to select PDF or image files";
          return;
        }

        const fileNames = Array.from(files)
          .map((f) => f.name)
          .join(", ");
        fileLabel.textContent = `üìÅ Selected: ${fileNames}`;
      });

      // Extraction functions
      function sanitiseMatch(rawMatch) {
        if (!rawMatch) return null;
        const s = rawMatch
          .replace(/\s+/g, "")
          .replace(/[^A-Za-z0-9]/g, "")
          .toUpperCase();
        return PL_CANON.test(s) ? s : null;
      }

      function findAndSanitiseAll(rawText) {
        const out = [];
        if (!rawText) return out;
        PL_FLEX_GLOBAL.lastIndex = 0;
        let m;
        while ((m = PL_FLEX_GLOBAL.exec(rawText)) !== null) {
          const san = sanitiseMatch(m[0]);
          if (san) out.push(san);
        }
        PL_FLEX_GLOBAL.lastIndex = 0;
        return out;
      }

      async function extractPLsFromPDF(file, progressCallback) {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        let found = [];

        for (let p = 1; p <= pdf.numPages; p++) {
          if (progressCallback) progressCallback((p / pdf.numPages) * 80);

          const page = await pdf.getPage(p);
          const textContent = await page.getTextContent();
          const tokens = textContent.items.map((it) => ({
            x: it.transform[4],
            text: (it.str || "").trim(),
          }));

          // Token stitching approach
          const pageCandidates = tokens.filter((t) => {
            return (
              (typeof t.x === "number" && t.x >= PL_X_MIN && t.x <= PL_X_MAX) ||
              /^P\s*\d/i.test(t.text) ||
              PL_FLEX.test(t.text)
            );
          });

          for (let i = 0; i < pageCandidates.length; i++) {
            let s = "";
            for (let j = 0; j < 4 && i + j < pageCandidates.length; j++) {
              s += pageCandidates[i + j].text;
              const m = s.match(PL_FLEX);
              if (m) {
                const san = sanitiseMatch(m[0]);
                if (san) found.push(san);
              }
            }
          }

          // Fallback to full page text
          if (found.length === 0) {
            const combined = textContent.items.map((it) => it.str).join(" ");
            const hits = findAndSanitiseAll(combined);
            found = found.concat(hits);
          }
        }

        // OCR fallback if needed
        if (found.length === 0) {
          if (progressCallback) progressCallback(85);
          for (let p = 1; p <= pdf.numPages; p++) {
            const page = await pdf.getPage(p);
            const viewport = page.getViewport({ scale: 2 });
            const canvas = document.createElement("canvas");
            canvas.width = Math.round(viewport.width);
            canvas.height = Math.round(viewport.height);
            const ctx = canvas.getContext("2d");
            await page.render({ canvasContext: ctx, viewport }).promise;
            const ocr = await Tesseract.recognize(canvas, "eng", {
              logger: () => {},
            });
            const text = ocr.data?.text || "";
            const hits = findAndSanitiseAll(text);
            found = found.concat(hits);
          }
        }

        return found;
      }

      async function extractPLsFromImage(file, progressCallback) {
        if (progressCallback) progressCallback(20);
        const blobURL = URL.createObjectURL(file);
        if (progressCallback) progressCallback(50);
        const ocr = await Tesseract.recognize(blobURL, "eng", {
          logger: () => {},
        });
        if (progressCallback) progressCallback(90);
        URL.revokeObjectURL(blobURL);
        const text = ocr.data?.text || "";
        return findAndSanitiseAll(text);
      }

      function finalizePLs(rawList) {
        const sanitised = rawList.map((r) => normalize(r)).filter(Boolean);
        const dedup = [...new Set(sanitised)];
        const filtered = dedup.filter((x) => PL_CANON.test(x));
        filtered.sort((a, b) => {
          const prefixA = (a.match(/^P\d{2}[A-Z]{2}/)?.[0] || "").toLowerCase();
          const prefixB = (b.match(/^P\d{2}[A-Z]{2}/)?.[0] || "").toLowerCase();
          const numA = parseInt(a.match(/\d+$/)?.[0] || "0", 10);
          const numB = parseInt(b.match(/\d+$/)?.[0] || "0", 10);
          if (prefixA < prefixB) return -1;
          if (prefixA > prefixB) return 1;
          return numA - numB;
        });
        return filtered;
      }

      // Extract button handler
      extractBtn.addEventListener("click", async () => {
        const files = [...(fileInput.files || [])];
        if (files.length === 0) {
          showStatus(extractStatus, "‚ùå Please select files first", "error");
          return;
        }

        extractBtn.disabled = true;
        extractProgress.classList.remove("hidden");
        showStatus(extractStatus, "üîç Extracting PL codes...", "info");
        updateProgress(0);

        let allFound = [];
        for (let i = 0; i < files.length; i++) {
          const file = files[i];
          const baseProgress = (i / files.length) * 100;

          try {
            const type = (file.type || "").toLowerCase();
            let fileResults = [];

            if (type.includes("pdf")) {
              fileResults = await extractPLsFromPDF(file, (progress) => {
                updateProgress(baseProgress + progress / files.length);
              });
            } else {
              fileResults = await extractPLsFromImage(file, (progress) => {
                updateProgress(baseProgress + progress / files.length);
              });
            }

            allFound = allFound.concat(fileResults);
          } catch (err) {
            console.error("Extraction error:", err);
            showStatus(
              extractStatus,
              `‚ùå Error processing ${file.name}`,
              "error"
            );
          }
        }

        updateProgress(100);
        uniquePLs = finalizePLs(allFound);
        renderTable();

        extractBtn.disabled = false;
        extractProgress.classList.add("hidden");

        if (uniquePLs.length > 0) {
          showStatus(
            extractStatus,
            `‚úÖ Found ${uniquePLs.length} PL codes`,
            "success"
          );
          triggerHaptic(extractStatus);
        } else {
          showStatus(
            extractStatus,
            "‚ùå No PL codes found - check file quality",
            "error"
          );
        }
      });

      
// Camera functionality (QuaggaJS)
let quaggaRunning = false;

async function initializeCameras() {
  try {
    const devices = await Quagga.CameraAccess.enumerateVideoDevices();
    availableCameras = devices || [];
    if (availableCameras.length > 1) {
      switchCameraBtn.classList.remove("hidden");
    }
    return availableCameras.length > 0;
  } catch (error) {
    console.error("Camera initialization error:", error);
    return false;
  }
}

function startQuaggaWithDevice(device) {
  const deviceId = device?.deviceId || device?.id || device;
  return new Promise((resolve, reject) => {
    // Ensure camera permission first
    navigator.mediaDevices.getUserMedia({
      video: { deviceId: deviceId ? { exact: deviceId } : undefined, facingMode: deviceId ? undefined : "environment" }
    }).then(() => {
      Quagga.init({
        inputStream: {
          name: "Live",
          type: "LiveStream",
          target: videoEl, // use actual <video> element
          constraints: {
            deviceId: deviceId ? { exact: deviceId } : undefined,
            facingMode: deviceId ? undefined : "environment"
          }
        },
        decoder: { readers: ["code_128_reader"] },
        locate: true
      }, (err) => {
        if (err) {
          console.error("Quagga init error:", err);
          reject(err);
          return;
        }
        Quagga.start();
        quaggaRunning = true;
        Quagga.onDetected((data) => {
          const code = data?.codeResult?.code;
          if (code) onScanMatch(code);
        });
        resolve(true);
      });
    }).catch((err) => {
      console.error("Camera permission denied or unavailable:", err);
      reject(err);
    });
  });
}

startScanBtn.addEventListener("click", async () => {
  const hasCamera = await initializeCameras();
  if (!hasCamera) {
    showStatus(scanStatus, "‚ùå No camera found", "error");
    return;
  }
  const backCamera =
    availableCameras.find((d) => /back|rear|environment/i.test(d.label)) ||
    availableCameras[currentCameraIndex] ||
    availableCameras[0];
  await startQuaggaWithDevice(backCamera);
  videoContainer.classList.remove("hidden");
  videoEl.classList.remove("hidden");
  videoContainer.scrollIntoView({ behavior: "smooth" }); // auto-scroll to scanner
  startScanBtn.disabled = true;
  stopScanBtn.disabled = false;
  showStatus(scanStatus, "üì∑ Scanning... Point at PL codes", "success");
});

stopScanBtn.addEventListener("click", () => {
  if (quaggaRunning) {
    Quagga.stop();
    quaggaRunning = false;
  }
  videoContainer.classList.add("hidden");
  startScanBtn.disabled = uniquePLs.length === 0;
  stopScanBtn.disabled = true;
  switchCameraBtn.classList.add("hidden");
  showStatus(scanStatus, "‚è∏ Scanner stopped", "info");
});

switchCameraBtn.addEventListener("click", async () => {
  if (availableCameras.length <= 1) return;
  currentCameraIndex = (currentCameraIndex + 1) % availableCameras.length;
  const camera = availableCameras[currentCameraIndex];
  if (quaggaRunning) {
    Quagga.stop();
    quaggaRunning = false;
  }
  await startQuaggaWithDevice(camera);
  const cameraType = /back|rear|environment/i.test(camera.label)
    ? "üì∑ Back"
    : "ü§≥ Front";
  showStatus(scanStatus, `${cameraType} camera active`, "success");
});

window.addEventListener("beforeunload", () => {
  if (quaggaRunning) {
    Quagga.stop();
    quaggaRunning = false;
  }
});

clearBtn.addEventListener("click", () => {
        scannedSet.clear();
        scannedCount = 0;

        plRowMap.forEach((entry) => {
          entry.checkbox.checked = false;
          entry.row.classList.remove("scanned");
          entry.remarkCell.textContent = "Ready to scan";
        });

        updateCounter();
        updateTabCounts();
        renderTable(); // Refresh the current tab view
        lastScan.classList.add("hidden");
        showStatus(scanStatus, "üßπ All marks cleared", "info");
        triggerHaptic(clearBtn);
      });

      // Cleanup on page unload
      window.addEventListener("beforeunload", async () => {
        if (codeReader) {
          await codeReader.reset();
        }
      });

      // Tab switching functionality
      tabButtons.forEach((button) => {
        button.addEventListener("click", () => {
          // Update active tab
          tabButtons.forEach((btn) => btn.classList.remove("active"));
          button.classList.add("active");

          // Update active tab state
          activeTab = button.dataset.tab;

          // Re-render table with filtered data
          renderTable();

          // Haptic feedback
          triggerHaptic(button);
        });
      });

      // Initialize
      updateCounter();
      updateTabCounts();
      renderTable();
    </script>
  </body>
</html>
