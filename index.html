<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>PL Code Scanner</title>

    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/tesseract.js@v4.0.2/dist/tesseract.min.js"></script>
    <script src="https://unpkg.com/@zxing/library@latest"></script>

    <style>
      * {
        box-sizing: border-box;
      }

      body {
        font-family: Inter, system-ui, -apple-system, sans-serif;
        background: #f8fafc;
        margin: 0;
        padding: 0;
        line-height: 1.5;
      }

      .container {
        max-width: 100vw;
        padding: 12px;
      }

      /* Mobile-first cards */
      .card {
        background: #fff;
        border-radius: 16px;
        padding: 16px;
        margin-bottom: 16px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .card h2 {
        margin: 0 0 16px 0;
        font-size: 1.25rem;
        font-weight: 600;
        color: #1a202c;
      }

      /* Large mobile-friendly buttons */
      .btn {
        background: #3182ce;
        color: #fff;
        border: 0;
        padding: 14px 20px;
        border-radius: 12px;
        font-weight: 600;
        font-size: 16px;
        cursor: pointer;
        min-height: 48px;
        width: 100%;
        margin-bottom: 8px;
        transition: background 0.2s;
        touch-action: manipulation;
      }

      .btn:active {
        background: #2c5aa0;
        transform: scale(0.98);
      }

      .btn:disabled {
        background: #a0aec0;
        cursor: not-allowed;
        transform: none;
      }

      .btn-secondary {
        background: #718096;
      }

      .btn-secondary:active {
        background: #4a5568;
      }

      .btn-danger {
        background: #e53e3e;
      }

      .btn-danger:active {
        background: #c53030;
      }

      /* Mobile file input */
      .file-input-wrapper {
        position: relative;
        overflow: hidden;
        display: block;
        margin-bottom: 12px;
      }

      .file-input-wrapper input[type="file"] {
        position: absolute;
        left: -9999px;
      }

      .file-input-label {
        display: block;
        padding: 16px;
        background: #f7fafc;
        border: 2px dashed #cbd5e0;
        border-radius: 12px;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s;
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
      }

      .file-input-label:active {
        background: #edf2f7;
        border-color: #a0aec0;
      }

      /* Status messages */
      .status {
        padding: 12px 16px;
        border-radius: 8px;
        font-weight: 500;
        margin: 8px 0;
        text-align: center;
      }

      .status.info {
        background: #ebf8ff;
        color: #2c5aa0;
      }
      .status.success {
        background: #f0fff4;
        color: #2f855a;
      }
      .status.error {
        background: #fed7d7;
        color: #c53030;
      }
      .status.warning {
        background: #fffbeb;
        color: #d69e2e;
      }

      /* Video optimized for mobile */
      .video-container {
        position: relative;
        background: #000;
        border-radius: 12px;
        overflow: hidden;
        margin: 12px 0;
        min-height: 300px;
      }

      #video {
        width: 100%;
        height: auto;
        max-height: 60vh;
        display: block;
        object-fit: cover;
      }

      .video-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border: 3px solid #fff;
        border-radius: 8px;
        width: 250px;
        height: 100px;
        pointer-events: none;
        opacity: 0.8;
        box-shadow: 0 0 0 2px rgba(49, 130, 206, 0.5);
      }

      .video-overlay::after {
        content: 'Point barcode here';
        position: absolute;
        top: -30px;
        left: 50%;
        transform: translateX(-50%);
        color: #fff;
        background: rgba(0, 0, 0, 0.7);
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
      }

      /* Torch button */
      .torch-btn {
        position: absolute;
        top: 12px;
        right: 12px;
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        border: none;
        border-radius: 50%;
        width: 48px;
        height: 48px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 10;
        font-size: 18px;
      }

      .torch-btn:active {
        background: rgba(0, 0, 0, 0.8);
      }

      .torch-btn.active {
        background: rgba(255, 193, 7, 0.8);
      }

      /* Focus indicator */
      .focus-ring {
        position: absolute;
        border: 2px solid #fbbf24;
        border-radius: 8px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 5;
      }

      .focus-ring.active {
        opacity: 1;
      }

      /* Counter optimized for mobile */
      .counter {
        display: block;
        padding: 16px;
        border-radius: 12px;
        font-weight: 700;
        font-size: 18px;
        text-align: center;
        margin-bottom: 16px;
      }

      .counter.pending {
        background: #fed7d7;
        color: #c53030;
        border: 2px solid #feb2b2;
      }

      .counter.success {
        background: #c6f6d5;
        color: #2f855a;
        border: 2px solid #9ae6b4;
      }

      /* Mobile-optimized table */
      .table-container {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
        background: #fff;
      }

      .scroll-indicator {
        text-align: center;
        font-size: 12px;
        color: #718096;
        padding: 4px;
        background: #f7fafc;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        min-width: 400px;
      }

      thead th {
        background: #f7fafc;
        color: #2d3748;
        padding: 12px 8px;
        border-bottom: 2px solid #e2e8f0;
        text-align: left;
        font-weight: 600;
        font-size: 14px;
        position: sticky;
        top: 0;
      }

      tbody td {
        padding: 14px 8px;
        border-bottom: 1px solid #f1f5f9;
        font-size: 14px;
      }

      .scanned {
        background: #f0fff4 !important;
      }

      .flash-success {
        background: #c6f6d5 !important;
        animation: flash 0.5s ease;
      }

      .flash-warning {
        background: #fefcbf !important;
        animation: flash 0.5s ease;
      }

      .flash-error {
        background: #fed7d7 !important;
        animation: flash 0.5s ease;
      }

      @keyframes flash {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      .total-row td {
        font-weight: 700;
        background: #f7fafc;
        border-top: 2px solid #e2e8f0;
      }

      /* Mobile checkboxes */
      input[type="checkbox"] {
        width: 20px;
        height: 20px;
        cursor: pointer;
      }

      /* Camera controls */
      .camera-controls {
        display: flex;
        gap: 8px;
        margin: 12px 0;
      }

      .camera-controls button {
        flex: 1;
        margin-bottom: 0;
      }

      /* Last scan display */
      .last-scan {
        background: #f7fafc;
        padding: 12px;
        border-radius: 8px;
        margin: 8px 0;
        font-family: monospace;
        font-size: 14px;
        word-break: break-all;
        border-left: 4px solid #3182ce;
      }

      /* Progress indicator */
      .progress {
        width: 100%;
        height: 4px;
        background: #e2e8f0;
        border-radius: 2px;
        overflow: hidden;
        margin: 8px 0;
      }

      .progress-bar {
        height: 100%;
        background: #3182ce;
        border-radius: 2px;
        transition: width 0.3s ease;
        width: 0%;
      }

      /* Responsive adjustments */
      @media (min-width: 640px) {
        .container {
          padding: 20px;
        }
        .card {
          padding: 24px;
        }

        .btn-row {
          display: flex;
          gap: 12px;
        }

        .btn-row .btn {
          margin-bottom: 0;
        }
      }

      /* Hide elements when not needed */
      .hidden {
        display: none;
      }

      /* Haptic feedback simulation */
      .haptic {
        animation: haptic 0.1s ease;
      }

      /* Tabs styling */
      .tabs {
        display: flex;
        background: #f7fafc;
        border-radius: 12px;
        padding: 4px;
        margin-bottom: 16px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      .tab {
        flex: 1;
        min-width: 100px;
        padding: 12px 8px;
        text-align: center;
        background: transparent;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
      }

      .tab.active {
        background: #3182ce;
        color: #fff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .tab:not(.active) {
        color: #4a5568;
      }

      .tab:not(.active):active {
        background: #edf2f7;
      }

      .tab-badge {
        display: inline-block;
        background: rgba(255, 255, 255, 0.2);
        color: inherit;
        padding: 2px 6px;
        border-radius: 10px;
        font-size: 12px;
        font-weight: 700;
        margin-left: 4px;
      }

      .tab:not(.active) .tab-badge {
        background: #e2e8f0;
        color: #4a5568;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- File Upload Section -->
      <div class="card">
        <h2>üìÑ Upload Files</h2>

        <div class="file-input-wrapper">
          <input
            id="fileInput"
            type="file"
            accept="application/pdf,image/*"
            multiple
          />
          <label for="fileInput" class="file-input-label">
            <span id="fileLabel">üìÅ Tap to select PDF or image files</span>
          </label>
        </div>

        <button id="extractBtn" class="btn">üîç Extract PL Codes</button>

        <div class="progress hidden" id="extractProgress">
          <div class="progress-bar" id="extractProgressBar"></div>
        </div>

        <div id="extractStatus"></div>
      </div>

      <!-- Scanner Section -->
      <div class="card">
        <h2>üì± Camera Scanner</h2>

        <div class="camera-controls btn-row">
          <button id="startScanBtn" class="btn" disabled>
            üì∑ Start Scanner
          </button>
          <button id="switchCameraBtn" class="btn btn-secondary hidden">
            üîÑ Switch
          </button>
        </div>

        <div class="camera-controls btn-row">
          <button id="stopScanBtn" class="btn btn-danger" disabled>
            ‚èπ Stop
          </button>
          <button id="clearBtn" class="btn btn-secondary" disabled>
            üßπ Clear All
          </button>
        </div>

        <div class="video-container hidden" id="videoContainer">
          <video id="video" playsinline muted autoplay></video>
          <div class="video-overlay"></div>
          <div class="focus-ring" id="focusRing"></div>
          <button class="torch-btn hidden" id="torchBtn">üí°</button>
        </div>

        <div id="scanStatus" class="status info">
          Scanner ready - upload files first
        </div>
        <div id="lastScan" class="last-scan hidden"></div>
      </div>

      <!-- Results Section -->
      <div class="card">
        <div id="counter" class="counter pending">No codes loaded</div>

        <!-- Tabs -->
        <div class="tabs">
          <button class="tab active" data-tab="all">
            üìã All PLs <span class="tab-badge" id="allCount">0</span>
          </button>
          <button class="tab" data-tab="unmatched">
            ‚ùå Unmatched <span class="tab-badge" id="unmatchedCount">0</span>
          </button>
          <button class="tab" data-tab="completed">
            ‚úÖ Completed <span class="tab-badge" id="completedCount">0</span>
          </button>
        </div>

        <div class="table-container">
          <div class="scroll-indicator">‚Üê Swipe to see all columns ‚Üí</div>
          <table id="plTable" aria-label="PL codes table">
            <thead>
              <tr>
                <th style="width: 50px">#</th>
                <th style="width: 50px; text-align: center">‚úì</th>
                <th style="width: 140px">PL Code</th>
                <th>Status / Progress</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td
                  colspan="4"
                  style="text-align: center; padding: 40px; color: #718096"
                >
                  Upload files to see PL codes here
                </td>
              </tr>
            </tbody>
            <tfoot>
              <tr class="total-row">
                <td colspan="4" id="totalCell">Total: 0 codes</td>
              </tr>
            </tfoot>
          </table>
        </div>
      </div>

      <!-- Instructions -->
      <div class="card">
        <h2>üìã Instructions</h2>
        <ul>
          <li>
            <strong>Step 1:</strong> Upload PDF files or images containing PL
            codes
          </li>
          <li><strong>Step 2:</strong> Start the camera scanner</li>
          <li>
            <strong>Step 3:</strong> Point camera at PL codes to mark them as
            scanned
          </li>
          <li>
            <strong>Tip:</strong> Tap the video to focus, use torch in low light
          </li>
        </ul>
      </div>
    </div>

    <script>
      // Configuration
      const PL_CANON = /^P\d{2}[A-Z]{2}\d{7}$/;
      const PL_FLEX_GLOBAL = /P\s*\d{2}\s*[A-Za-z]{2}\s*\d{6,8}/gi;
      const PL_FLEX = /P\s*\d{2}\s*[A-Za-z]{2}\s*\d{6,8}/i;
      const PL_X_MIN = 700;
      const PL_X_MAX = 790;

      // Elements
      const fileInput = document.getElementById("fileInput");
      const fileLabel = document.getElementById("fileLabel");
      const extractBtn = document.getElementById("extractBtn");
      const extractStatus = document.getElementById("extractStatus");
      const extractProgress = document.getElementById("extractProgress");
      const extractProgressBar = document.getElementById("extractProgressBar");

      const startScanBtn = document.getElementById("startScanBtn");
      const stopScanBtn = document.getElementById("stopScanBtn");
      const switchCameraBtn = document.getElementById("switchCameraBtn");
      const clearBtn = document.getElementById("clearBtn");
      const scanStatus = document.getElementById("scanStatus");
      const lastScan = document.getElementById("lastScan");
      const videoEl = document.getElementById("video");
      const videoContainer = document.getElementById("videoContainer");
      const torchBtn = document.getElementById("torchBtn");
      const focusRing = document.getElementById("focusRing");

      const tableBody = document.querySelector("#plTable tbody");
      const totalCell = document.getElementById("totalCell");
      const counterEl = document.getElementById("counter");

      // Tab elements
      const tabButtons = document.querySelectorAll(".tab");
      const allCountEl = document.getElementById("allCount");
      const unmatchedCountEl = document.getElementById("unmatchedCount");
      const completedCountEl = document.getElementById("completedCount");

      // State
      let uniquePLs = [];
      let plRowMap = new Map();
      let scannedSet = new Set();
      let scannedCount = 0;
      let codeReader = null;
      let availableCameras = [];
      let currentCameraIndex = 0;
      let activeTab = "all";
      let currentStream = null;
      let torchEnabled = false;
      let scanningActive = false;

      // Utility functions
      const normalize = (s) =>
        (s || "")
          .toString()
          .replace(/[^A-Za-z0-9]/g, "")
          .toUpperCase();

      function showStatus(element, message, type = "info") {
        element.className = `status ${type}`;
        element.textContent = message;
        element.style.display = "block";
      }

      function triggerHaptic(element) {
        if ("vibrate" in navigator) {
          navigator.vibrate(50);
        }
        element.classList.add("haptic");
        setTimeout(() => element.classList.remove("haptic"), 100);
      }

      function updateProgress(percent) {
        extractProgressBar.style.width = `${percent}%`;
      }

      function updateCounter() {
        const total = uniquePLs.length;
        const done = scannedCount >= total && total > 0;

        if (total === 0) {
          counterEl.textContent = "No codes loaded";
          counterEl.className = "counter pending";
        } else if (done) {
          counterEl.textContent = `‚úÖ All ${total} codes scanned!`;
          counterEl.className = "counter success";
          triggerHaptic(counterEl);
        } else {
          counterEl.textContent = `${scannedCount} / ${total} codes scanned`;
          counterEl.className = "counter pending";
        }
      }

      function updateTabCounts() {
        const total = uniquePLs.length;
        const completed = scannedCount;
        const unmatched = total - completed;

        allCountEl.textContent = total;
        completedCountEl.textContent = completed;
        unmatchedCountEl.textContent = unmatched;
      }

      function groupByMPL(pls) {
        const groups = {};
        pls.forEach((pl) => {
          const mpl = pl.substring(0, 6);
          if (!groups[mpl]) groups[mpl] = [];
          groups[mpl].push(pl);
        });
        return groups;
      }

      function updateMPLProgress(mpl) {
        console.log(`MPL ${mpl} progress updated`);
      }

      function renderTable() {
        tableBody.innerHTML = "";
        plRowMap.clear();

        if (uniquePLs.length === 0) {
          const emptyRow = document.createElement("tr");
          emptyRow.innerHTML =
            '<td colspan="4" style="text-align: center; padding: 40px; color: #718096;">Upload files to see PL codes here</td>';
          tableBody.appendChild(emptyRow);
          totalCell.textContent = "Total: 0 codes";
          return;
        }

        let filteredPLs = uniquePLs;
        if (activeTab === "completed") {
          filteredPLs = uniquePLs.filter((pl) => scannedSet.has(normalize(pl)));
        } else if (activeTab === "unmatched") {
          filteredPLs = uniquePLs.filter(
            (pl) => !scannedSet.has(normalize(pl))
          );
        }

        filteredPLs.forEach((pl, i) => {
          const tr = document.createElement("tr");
          const isScanned = scannedSet.has(normalize(pl));
          tr.innerHTML = `
          <td style="text-align: center; font-weight: 600;">${i + 1}</td>
          <td style="text-align: center;">
            <input type="checkbox" style="transform: scale(1.2);" ${
              isScanned ? "checked" : ""
            }>
          </td>
          <td style="font-family: monospace; font-weight: 600;">${pl}</td>
          <td class="remark-cell">${
            isScanned ? "‚úÖ Scanned" : "Ready to scan"
          }</td>
        `;

          if (isScanned) {
            tr.classList.add("scanned");
          }

          tableBody.appendChild(tr);
          const checkbox = tr.querySelector('input[type="checkbox"]');
          const remarkCell = tr.querySelector(".remark-cell");

          plRowMap.set(normalize(pl), { row: tr, checkbox, remarkCell });
        });

        totalCell.textContent = `Total: ${filteredPLs.length} codes`;

        startScanBtn.disabled = uniquePLs.length === 0;
        clearBtn.disabled = uniquePLs.length === 0;

        if (uniquePLs.length > 0) {
          showStatus(
            scanStatus,
            "üì∑ Ready to scan - tap Start Scanner",
            "success"
          );
        }
      }

      function flashRow(row, type = "success") {
        row.classList.add(`flash-${type}`);
        setTimeout(() => {
          row.classList.remove(`flash-${type}`);
        }, 500);
      }

      function onScanMatch(rawCode) {
        const code = normalize(rawCode);
        lastScan.textContent = `Last: ${code || rawCode}`;
        lastScan.classList.remove("hidden");

        PL_FLEX_GLOBAL.lastIndex = 0;
        const matches = [...(rawCode.match(PL_FLEX_GLOBAL) || [])];
        let candidate = null;

        if (matches.length) {
          candidate = normalize(matches[0]);
        } else if (PL_CANON.test(code)) {
          candidate = code;
        }

        if (!candidate) {
          showStatus(
            scanStatus,
            `‚ùå No PL pattern found in: ${rawCode}`,
            "error"
          );
          document.querySelector("#plTable").classList.add("flash-error");
          setTimeout(
            () =>
              document
                .querySelector("#plTable")
                .classList.remove("flash-error"),
            300
          );
          return;
        }

        const entry = plRowMap.get(candidate);
        if (!entry) {
          showStatus(
            scanStatus,
            `‚ùå Code not in list: ${candidate}`,
            "warning"
          );
          document.querySelector("#plTable").classList.add("flash-warning");
          setTimeout(
            () =>
              document
                .querySelector("#plTable")
                .classList.remove("flash-warning"),
            300
          );
          return;
        }

        if (scannedSet.has(candidate)) {
          entry.remarkCell.textContent = `‚úÖ Already scanned (${new Date().toLocaleTimeString()})`;
          showStatus(scanStatus, `‚ö† Already scanned: ${candidate}`, "warning");
          flashRow(entry.row, "warning");
          return;
        }

        scannedSet.add(candidate);
        entry.checkbox.checked = true;
        entry.row.classList.add("scanned");
        entry.remarkCell.textContent = `‚úÖ Scanned at ${new Date().toLocaleTimeString()}`;
        flashRow(entry.row, "success");
        scannedCount++;

        updateCounter();
        updateTabCounts();

        if (activeTab === "unmatched") {
          renderTable();
        }

        showStatus(scanStatus, `‚úÖ Matched: ${candidate}`, "success");
        triggerHaptic(document.body);
      }

      // Camera constraints optimized for mobile
      function getCameraConstraints(cameraId = null) {
        const constraints = {
          video: {
            width: { min: 640, ideal: 1280, max: 1920 },
            height: { min: 480, ideal: 720, max: 1080 },
            aspectRatio: { ideal: 16/9 },
            frameRate: { ideal: 30, max: 30 },
            facingMode: cameraId ? undefined : { ideal: 'environment' }
          }
        };

        if (cameraId) {
          constraints.video.deviceId = { exact: cameraId };
        }

        return constraints;
      }

      // Focus functionality
      async function triggerFocus(x, y) {
        if (!currentStream) return;

        const track = currentStream.getVideoTracks()[0];
        const capabilities = track.getCapabilities();

        if (capabilities.focusMode && capabilities.focusMode.includes('single-shot')) {
          try {
            await track.applyConstraints({
              advanced: [{ focusMode: 'single-shot' }]
            });

            // Show focus ring
            const rect = videoEl.getBoundingClientRect();
            const focusX = ((x - rect.left) / rect.width) * videoEl.offsetWidth;
            const focusY = ((y - rect.top) / rect.height) * videoEl.offsetHeight;

            focusRing.style.left = (focusX - 50) + 'px';
            focusRing.style.top = (focusY - 50) + 'px';
            focusRing.style.width = '100px';
            focusRing.style.height = '100px';
            focusRing.classList.add('active');

            setTimeout(() => {
              focusRing.classList.remove('active');
            }, 1000);

          } catch (err) {
            console.log('Focus adjustment failed:', err);
          }
        }
      }

      // Video tap-to-focus
      videoEl.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        triggerFocus(touch.clientX, touch.clientY);
      });

      videoEl.addEventListener('click', (e) => {
        triggerFocus(e.clientX, e.clientY);
      });

      // Torch functionality
      async function toggleTorch() {
        if (!currentStream) return;

        const track = currentStream.getVideoTracks()[0];
        const capabilities = track.getCapabilities();

        if (capabilities.torch) {
          try {
            torchEnabled = !torchEnabled;
            await track.applyConstraints({
              advanced: [{ torch: torchEnabled }]
            });

            torchBtn.classList.toggle('active', torchEnabled);
            torchBtn.textContent = torchEnabled ? 'üî¶' : 'üí°';
          } catch (err) {
            console.log('Torch control failed:', err);
          }
        }
      }

      torchBtn.addEventListener('click', toggleTorch);

      // File handling
      fileInput.addEventListener("change", (e) => {
        const files = e.target.files;
        if (files.length === 0) {
          fileLabel.textContent = "üìÅ Tap to select PDF or image files";
          return;
        }

        const fileNames = Array.from(files)
          .map((f) => f.name)
          .join(", ");
        fileLabel.textContent = `üìÅ Selected: ${fileNames}`;
      });

      // Extraction functions (keeping your existing implementation)
      function sanitiseMatch(rawMatch) {
        if (!rawMatch) return null;
        const s = rawMatch
          .replace(/\s+/g, "")
          .replace(/[^A-Za-z0-9]/g, "")
          .toUpperCase();
        return PL_CANON.test(s) ? s : null;
      }

      function findAndSanitiseAll(rawText) {
        const out = [];
        if (!rawText) return out;
        PL_FLEX_GLOBAL.lastIndex = 0;
        let m;
        while ((m = PL_FLEX_GLOBAL.exec(rawText)) !== null) {
          const san = sanitiseMatch(m[0]);
          if (san) out.push(san);
        }
        PL_FLEX_GLOBAL.lastIndex = 0;
        return out;
      }

      async function extractPLsFromPDF(file, progressCallback) {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        let found = [];

        for (let p = 1; p <= pdf.numPages; p++) {
          if (progressCallback) progressCallback((p / pdf.numPages) * 80);

          const page = await pdf.getPage(p);
          const textContent = await page.getTextContent();
          const tokens = textContent.items.map((it) => ({
            x: it.transform[4],
            text: (it.str || "").trim(),
          }));

          const pageCandidates = tokens.filter((t) => {
            return (
              (typeof t.x === "number" && t.x >= PL_X_MIN && t.x <= PL_X_MAX) ||
              /^P\s*\d/i.test(t.text) ||
              PL_FLEX.test(t.text)
            );
          });

          for (let i = 0; i < pageCandidates.length; i++) {
            let s = "";
            for (let j = 0; j < 4 && i + j < pageCandidates.length; j++) {
              s += pageCandidates[i + j].text;
              const m = s.match(PL_FLEX);
              if (m) {
                const san = sanitiseMatch(m[0]);
                if (san) found.push(san);
              }
            }
          }

          if (found.length === 0) {
            const combined = textContent.items.map((it) => it.str).join(" ");
            const hits = findAndSanitiseAll(combined);
            found = found.concat(hits);
          }
        }

        if (found.length === 0) {
          if (progressCallback) progressCallback(85);
          for (let p = 1; p <= pdf.numPages; p++) {
            const page = await pdf.getPage(p);
            const viewport = page.getViewport({ scale: 2 });
            const canvas = document.createElement("canvas");
            canvas.width = Math.round(viewport.width);
            canvas.height = Math.round(viewport.height);
            const ctx = canvas.getContext("2d");
            await page.render({ canvasContext: ctx, viewport }).promise;
            const ocr = await Tesseract.recognize(canvas, "eng", {
              logger: () => {},
            });
            const text = ocr.data?.text || "";
            const hits = findAndSanitiseAll(text);
            found = found.concat(hits);
          }
        }

        return found;
      }

      async function extractPLsFromImage(file, progressCallback) {
        if (progressCallback) progressCallback(20);
        const blobURL = URL.createObjectURL(file);
        if (progressCallback) progressCallback(50);
        const ocr = await Tesseract.recognize(blobURL, "eng", {
          logger: () => {},
        });
        if (progressCallback) progressCallback(90);
        URL.revokeObjectURL(blobURL);
        const text = ocr.data?.text || "";
        return findAndSanitiseAll(text);
      }

      function finalizePLs(rawList) {
        const sanitised = rawList.map((r) => normalize(r)).filter(Boolean);
        const dedup = [...new Set(sanitised)];
        const filtered = dedup.filter((x) => PL_CANON.test(x));
        filtered.sort((a, b) => {
          const prefixA = (a.match(/^P\d{2}[A-Z]{2}/)?.[0] || "").toLowerCase();
          const prefixB = (b.match(/^P\d{2}[A-Z]{2}/)?.[0] || "").toLowerCase();
          const numA = parseInt(a.match(/\d+$/)?.[0] || "0", 10);
          const numB = parseInt(b.match(/\d+$/)?.[0] || "0", 10);
          if (prefixA < prefixB) return -1;
          if (prefixA > prefixB) return 1;
          return numA - numB;
        });
        return filtered;
      }

      // Extract button handler
      extractBtn.addEventListener("click", async () => {
        const files = [...(fileInput.files || [])];
        if (files.length === 0) {
          showStatus(extractStatus, "‚ùå Please select files first", "error");
          return;
        }

        extractBtn.disabled = true;
        extractProgress.classList.remove("hidden");
        showStatus(extractStatus, "üîç Extracting PL codes...", "info");
        updateProgress(0);

        let allFound = [];
        for (let i = 0; i < files.length; i++) {
          const file = files[i];
          const baseProgress = (i / files.length) * 100;

          try {
            const type = (file.type || "").toLowerCase();
            let fileResults = [];

            if (type.includes("pdf")) {
              fileResults = await extractPLsFromPDF(file, (progress) => {
                updateProgress(baseProgress + progress / files.length);
              });
            } else {
              fileResults = await extractPLsFromImage(file, (progress) => {
                updateProgress(baseProgress + progress / files.length);
              });
            }

            allFound = allFound.concat(fileResults);
          } catch (err) {
            console.error("Extraction error:", err);
            showStatus(
              extractStatus,
              `‚ùå Error processing ${file.name}`,
              "error"
            );
          }
        }

        updateProgress(100);
        uniquePLs = finalizePLs(allFound);
        renderTable();

        extractBtn.disabled = false;
        extractProgress.classList.add("hidden");

        if (uniquePLs.length > 0) {
          showStatus(
            extractStatus,
            `‚úÖ Found ${uniquePLs.length} PL codes`,
            "success"
          );
          triggerHaptic(extractStatus);
        } else {
          showStatus(
            extractStatus,
            "‚ùå No PL codes found - check file quality",
            "error"
          );
        }
      });

      // Enhanced camera functionality
      async function initializeCameras() {
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          availableCameras = devices.filter(device => device.kind === 'videoinput');

          if (availableCameras.length > 1) {
            switchCameraBtn.classList.remove("hidden");
          }

          return availableCameras.length > 0;
        } catch (error) {
          console.error("Camera initialization error:", error);
          return false;
        }
      }

      async function startCamera(cameraId = null) {
        try {
          // Stop existing stream
          if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
          }

          const constraints = getCameraConstraints(cameraId);
          currentStream = await navigator.mediaDevices.getUserMedia(constraints);
          
          videoEl.srcObject = currentStream;

          // Wait for video metadata to load
          return new Promise((resolve, reject) => {
            videoEl.onloadedmetadata = async () => {
              try {
                await videoEl.play();
                
                // Apply advanced camera settings for mobile
                const track = currentStream.getVideoTracks()[0];
                const capabilities = track.getCapabilities();
                
                // Enable continuous autofocus if available
                if (capabilities.focusMode && capabilities.focusMode.includes('continuous')) {
                  try {
                    await track.applyConstraints({
                      advanced: [{ focusMode: 'continuous' }]
                    });
                  } catch (err) {
                    console.log('Continuous focus not available:', err);
                  }
                }

                // Show torch button if available
                if (capabilities.torch) {
                  torchBtn.classList.remove('hidden');
                }

                scanningActive = true;
                startBarcodeDetection();
                resolve();
              } catch (err) {
                reject(err);
              }
            };

            videoEl.onerror = reject;
            
            // Timeout fallback
            setTimeout(() => {
              if (!scanningActive) {
                reject(new Error('Video loading timeout'));
              }
            }, 10000);
          });

        } catch (error) {
          console.error("Camera start error:", error);
          throw error;
        }
      }

      // Enhanced barcode detection with mobile optimization
      function startBarcodeDetection() {
        if (!codeReader) {
          codeReader = new ZXing.BrowserMultiFormatReader();
        }

        // Configure reader for better mobile performance
        const hints = new Map();
        hints.set(ZXing.DecodeHintType.TRY_HARDER, true);
        hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [
          ZXing.BarcodeFormat.CODE_128,
          ZXing.BarcodeFormat.CODE_39,
          ZXing.BarcodeFormat.EAN_13,
          ZXing.BarcodeFormat.EAN_8,
          ZXing.BarcodeFormat.UPC_A
        ]);

        const scanInterval = setInterval(() => {
          if (!scanningActive || videoEl.readyState !== videoEl.HAVE_ENOUGH_DATA) {
            return;
          }

          try {
            // Create canvas for frame capture
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = videoEl.videoWidth;
            canvas.height = videoEl.videoHeight;
            
            if (canvas.width === 0 || canvas.height === 0) return;
            
            ctx.drawImage(videoEl, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Use ZXing to decode
            const result = codeReader.decodeFromImageData(imageData);
            if (result && result.text) {
              onScanMatch(result.text);
            }
          } catch (error) {
            // Silent error handling for continuous scanning
          }
        }, 100); // 10 FPS scanning rate

        // Store interval for cleanup
        videoEl.scanInterval = scanInterval;
      }

      // Camera control handlers
      startScanBtn.addEventListener("click", async () => {
        const hasCamera = await initializeCameras();
        if (!hasCamera) {
          showStatus(scanStatus, "‚ùå No camera found", "error");
          return;
        }

        try {
          showStatus(scanStatus, "üì∑ Starting camera...", "info");
          
          // Prefer back camera on mobile
          const backCamera = availableCameras.find((d) =>
            /back|rear|environment/i.test(d.label)
          );
          const selectedCamera = backCamera || availableCameras[currentCameraIndex];

          await startCamera(selectedCamera?.deviceId);

          videoContainer.classList.remove("hidden");
          startScanBtn.disabled = true;
          stopScanBtn.disabled = false;
          
          if (availableCameras.length > 1) {
            switchCameraBtn.classList.remove("hidden");
          }

          showStatus(scanStatus, "üì∑ Scanning active - point at barcodes", "success");
        } catch (error) {
          console.error("Camera start error:", error);
          showStatus(
            scanStatus,
            "‚ùå Camera error - check permissions",
            "error"
          );
          scanningActive = false;
        }
      });

      stopScanBtn.addEventListener("click", async () => {
        scanningActive = false;
        
        if (videoEl.scanInterval) {
          clearInterval(videoEl.scanInterval);
        }

        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop());
          currentStream = null;
        }

        videoContainer.classList.add("hidden");
        torchBtn.classList.add("hidden");
        switchCameraBtn.classList.add("hidden");
        
        startScanBtn.disabled = uniquePLs.length === 0;
        stopScanBtn.disabled = true;
        
        torchEnabled = false;
        torchBtn.classList.remove('active');
        torchBtn.textContent = 'üí°';
        
        showStatus(scanStatus, "‚è∏ Scanner stopped", "info");
      });

      switchCameraBtn.addEventListener("click", async () => {
        if (availableCameras.length <= 1) return;

        currentCameraIndex = (currentCameraIndex + 1) % availableCameras.length;
        const camera = availableCameras[currentCameraIndex];

        try {
          showStatus(scanStatus, "üîÑ Switching camera...", "info");
          await startCamera(camera.deviceId);

          const cameraType = /back|rear|environment/i.test(camera.label)
            ? "üì∑ Back"
            : "ü§≥ Front";
          showStatus(scanStatus, `${cameraType} camera active`, "success");
        } catch (error) {
          console.error("Camera switch error:", error);
          showStatus(scanStatus, "‚ùå Failed to switch camera", "error");
        }
      });

      clearBtn.addEventListener("click", () => {
        scannedSet.clear();
        scannedCount = 0;

        plRowMap.forEach((entry) => {
          entry.checkbox.checked = false;
          entry.row.classList.remove("scanned");
          entry.remarkCell.textContent = "Ready to scan";
        });

        updateCounter();
        updateTabCounts();
        renderTable();
        lastScan.classList.add("hidden");
        showStatus(scanStatus, "üßπ All marks cleared", "info");
        triggerHaptic(clearBtn);
      });

      // Cleanup on page unload
      window.addEventListener("beforeunload", async () => {
        scanningActive = false;
        if (videoEl.scanInterval) {
          clearInterval(videoEl.scanInterval);
        }
        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop());
        }
      });

      // Tab switching functionality
      tabButtons.forEach((button) => {
        button.addEventListener("click", () => {
          tabButtons.forEach((btn) => btn.classList.remove("active"));
          button.classList.add("active");

          activeTab = button.dataset.tab;
          renderTable();
          triggerHaptic(button);
        });
      });

      // Initialize
      updateCounter();
      updateTabCounts();
      renderTable();
    </script>
  </body>
</html>
