<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>PL Code Scanner</title>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" onerror="console.warn('PDF.js failed to load')"></script>
  <script src="https://unpkg.com/tesseract.js@v4.0.2/dist/tesseract.min.js" onerror="console.warn('Tesseract.js failed to load')"></script>

  <style>
    * { box-sizing: border-box; }
    body { font-family: Inter, system-ui, -apple-system, sans-serif; background:#f8fafc; margin:0; padding:0; }
    .container { max-width:100vw; padding:12px; }
    .card { background:#fff; border-radius:16px; padding:16px; margin-bottom:16px; box-shadow:0 2px 8px rgba(0,0,0,0.1); }
    .card h2 { margin:0 0 16px 0; font-size:1.25rem; font-weight:600; color:#1a202c; }
    .btn { background:#3182ce; color:#fff; border:0; padding:14px 20px; border-radius:12px; font-weight:600; font-size:16px; cursor:pointer; min-height:48px; width:100%; margin-bottom:8px; transition: all 0.2s ease; }
    .btn:hover:not(:disabled) { background:#2c5282; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(49, 130, 206, 0.3); }
    .btn:active:not(:disabled) { transform: scale(0.98); }
    .btn:disabled { background:#a0aec0; cursor:not-allowed; transform:none; }
    .btn-secondary { background:#718096; }
    .btn-secondary:hover:not(:disabled) { background:#4a5568; }
    .btn-danger { background:#e53e3e; }
    .btn-danger:hover:not(:disabled) { background:#c53030; }
    .status { padding:12px 16px; border-radius:8px; font-weight:500; margin:8px 0; text-align:center; transition: all 0.3s ease; }
    .status.info { background:#ebf8ff; color:#2c5aa0; border-left:4px solid #3182ce; }
    .status.success { background:#f0fff4; color:#2f855a; border-left:4px solid #38a169; }
    .status.error { background:#fed7d7; color:#c53030; border-left:4px solid #e53e3e; }
    .status.warning { background:#fef5e7; color:#d69e2e; border-left:4px solid #d69e2e; }
    .last-scan { background:#f7fafc; padding:12px; border-radius:8px; margin:8px 0; font-family:monospace; font-size:14px; border-left:4px solid #3182ce; animation: fadeIn 0.3s ease; }
    .table-container { overflow-x:auto; border-radius:8px; border:1px solid #e2e8f0; background:#fff; max-height:400px; overflow-y:auto; }
    table { width:100%; border-collapse:collapse; min-width:400px; }
    thead th { background:#f7fafc; padding:12px 8px; border-bottom:2px solid #e2e8f0; text-align:left; font-weight:600; font-size:14px; position:sticky; top:0; z-index:10; }
    tbody td { padding:14px 8px; border-bottom:1px solid #f1f5f9; font-size:14px; }
    .scanned { background:#f0fff4 !important; animation: highlightScan 0.5s ease; }
    .counter { display:block; padding:16px; border-radius:12px; font-weight:700; font-size:18px; text-align:center; margin-bottom:16px; transition: all 0.3s ease; }
    .counter.pending { background:#fed7d7; color:#c53030; }
    .counter.success { background:#c6f6d5; color:#2f855a; }
    .modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(4px); }
    .modal.hidden { display: none; }
    .modal-content { max-width: 400px; width: 90%; text-align: center; animation: modalSlide 0.3s ease; }
    .modal-content h2 { font-size: 1.25rem; margin-bottom: 12px; color: #c53030; }
    .file-input { width:100%; padding:12px; margin-bottom:12px; border:2px dashed #cbd5e0; border-radius:8px; text-align:center; cursor:pointer; transition: all 0.2s ease; }
    .file-input:hover { border-color:#3182ce; background:#f7fafc; }
    .file-input.drag-over { border-color:#38a169; background:#f0fff4; }
    .progress-bar { width:100%; height:8px; background:#e2e8f0; border-radius:4px; overflow:hidden; margin:8px 0; }
    .progress-fill { height:100%; background:#3182ce; transition: width 0.3s ease; }
    .search-box { width:100%; padding:12px; font-size:16px; border-radius:8px; border:1px solid #cbd5e0; margin-bottom:12px; }
    .search-box:focus { outline:none; border-color:#3182ce; box-shadow:0 0 0 3px rgba(49, 130, 206, 0.1); }
    
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes highlightScan { 0% { background:#c6f6d5 !important; transform: scale(1.02); } 100% { background:#f0fff4 !important; transform: scale(1); } }
    @keyframes modalSlide { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    
    @media (max-width: 768px) {
      .container { padding: 8px; }
      .card { padding: 12px; margin-bottom: 12px; }
      .btn { padding: 12px 16px; font-size: 15px; }
      thead th, tbody td { padding: 10px 6px; font-size: 13px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- File Upload -->
    <div class="card">
      <h2>üìÑ Upload Files</h2>
      <div class="file-input" id="fileDropZone">
        <input id="fileInput" type="file" accept="application/pdf,image/*" multiple style="display:none;" />
        üìÅ Click to select files or drag & drop here
        <br><small>Supports PDF and images (PNG, JPG, etc.)</small>
      </div>
      <button id="extractBtn" class="btn">üîç Extract PL Codes</button>
      <div class="progress-bar hidden" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div id="extractStatus"></div>
    </div>

    <!-- Breakdown Summary -->
    <div id="summaryBreakdown" class="card" style="text-align:center; font-weight:600; font-size:16px; padding:12px; color:#2d3748;">
      No data loaded
    </div>

    <!-- Scanner -->
    <div class="card">
      <h2>üì± Barcode Scanner</h2>
      <input id="barcodeInput" class="search-box" type="text" placeholder="Scan barcode here..." autofocus />
      <div style="display:flex; gap:12px; margin-bottom:12px;">
        <button id="clearBtn" class="btn btn-secondary" disabled>üßπ Clear All</button>
        <button id="manualBtn" class="btn btn-secondary">‚úçÔ∏è Manual Entry</button>
      </div>
      <div id="scanStatus" class="status info">Scanner ready - upload files first</div>
      <div id="lastScan" class="last-scan hidden"></div>
    </div>

    <!-- Search and Filter -->
    <div class="card">
      <input id="searchInput" class="search-box" type="text" placeholder="üîç Search PL codes..." />
      <div style="display:flex; gap:8px; flex-wrap:wrap;">
        <button id="filterAll" class="btn btn-secondary" style="width:auto; padding:8px 16px;">All</button>
        <button id="filterScanned" class="btn btn-secondary" style="width:auto; padding:8px 16px;">‚úÖ Scanned</button>
        <button id="filterPending" class="btn btn-secondary" style="width:auto; padding:8px 16px;">‚ùå Pending</button>
      </div>
    </div>

    <!-- Extracted Results -->
    <div class="card">
      <div id="counter" class="counter pending">No codes loaded</div>
      <div class="table-container">
        <table id="plTable">
          <thead><tr><th>#</th><th>‚úì</th><th>PL Code</th><th>Status</th></tr></thead>
          <tbody><tr><td colspan="4" style="text-align:center; padding:40px; color:#718096">Upload files to see PL codes here</td></tr></tbody>
          <tfoot><tr><td colspan="4" id="totalCell">Total: 0 codes</td></tr></tfoot>
        </table>
      </div>
      <div style="margin-top:16px;">
        <button id="downloadBtn" class="btn">‚¨áÔ∏è Download Summary</button>
      </div>
    </div>

    <!-- Unmatched Entries -->
    <div class="card">
      <h2>‚ö†Ô∏è Unmatched Entries</h2>
      <div class="table-container">
        <table id="unmatchedTable">
          <thead><tr><th>#</th><th>Code</th><th>Source</th><th>Timestamp</th></tr></thead>
          <tbody><tr><td colspan="4" style="text-align:center; padding:40px; color:#718096">No unmatched codes</td></tr></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Confirm Modal -->
  <div id="confirmModal" class="modal hidden">
    <div class="modal-content card">
      <h2>‚ö† Confirm Action</h2>
      <p>Are you sure you want to clear all scanned marks?</p>
      <div style="display:flex; gap:12px; margin-top:16px;">
        <button id="confirmYes" class="btn btn-danger">Yes, Clear All</button>
        <button id="confirmNo" class="btn btn-secondary">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Manual Entry Modal -->
  <div id="manualModal" class="modal hidden">
    <div class="modal-content card">
      <h2>‚úçÔ∏è Manual Entry</h2>
      <p>Enter PL code manually:</p>
      <input id="manualInput" class="search-box" type="text" placeholder="P12AB1234567" />
      <div style="display:flex; gap:12px;">
        <button id="manualSubmit" class="btn">Add</button>
        <button id="manualCancel" class="btn btn-secondary">Cancel</button>
      </div>
    </div>
  </div>

<script>
  // Constants and Configuration
  const PL_CANON = /^P\d{2}[A-Z]{2}\d{7}$/;
  const PL_FLEX_GLOBAL = /P\s*\d{2}\s*[A-Za-z]{2}\s*\d{6,8}/gi;
  const PL_FLEX = /P\s*\d{2}\s*[A-Za-z]{2}\s*\d{6,8}/i;
  const PL_X_MIN = 700, PL_X_MAX = 790;
  const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB limit
  const DEBOUNCE_DELAY = 300;

  // DOM Elements
  const elements = {
    fileInput: document.getElementById("fileInput"),
    fileDropZone: document.getElementById("fileDropZone"),
    extractBtn: document.getElementById("extractBtn"),
    extractStatus: document.getElementById("extractStatus"),
    progressBar: document.getElementById("progressBar"),
    progressFill: document.getElementById("progressFill"),
    barcodeInput: document.getElementById("barcodeInput"),
    scanStatus: document.getElementById("scanStatus"),
    lastScan: document.getElementById("lastScan"),
    tableBody: document.querySelector("#plTable tbody"),
    totalCell: document.getElementById("totalCell"),
    counterEl: document.getElementById("counter"),
    clearBtn: document.getElementById("clearBtn"),
    confirmModal: document.getElementById("confirmModal"),
    confirmYes: document.getElementById("confirmYes"),
    confirmNo: document.getElementById("confirmNo"),
    manualBtn: document.getElementById("manualBtn"),
    manualModal: document.getElementById("manualModal"),
    manualInput: document.getElementById("manualInput"),
    manualSubmit: document.getElementById("manualSubmit"),
    manualCancel: document.getElementById("manualCancel"),
    downloadBtn: document.getElementById("downloadBtn"),
    unmatchedTable: document.getElementById("unmatchedTable").querySelector("tbody"),
    summaryBreakdown: document.getElementById("summaryBreakdown"),
    searchInput: document.getElementById("searchInput"),
    filterAll: document.getElementById("filterAll"),
    filterScanned: document.getElementById("filterScanned"),
    filterPending: document.getElementById("filterPending")
  };

  // Application State
  let appState = {
    uniquePLs: [],
    plRowMap: new Map(),
    scannedSet: new Set(),
    scannedCount: 0,
    unmatchedList: [],
    currentFilter: 'all',
    searchTerm: '',
    isProcessing: false
  };

  // Utility Functions
  const normalize = (s) => (s || "").replace(/[^A-Za-z0-9]/g, "").toUpperCase();
  
  const debounce = (func, delay) => {
    let timeoutId;
    return (...args) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func.apply(null, args), delay);
    };
  };

  const showStatus = (el, msg, type = "info") => {
    el.className = `status ${type}`;
    el.textContent = msg;
  };

  const updateProgress = (percent) => {
    elements.progressFill.style.width = `${percent}%`;
    if (percent === 0) {
      elements.progressBar.classList.add('hidden');
    } else {
      elements.progressBar.classList.remove('hidden');
    }
  };

  const validateFile = (file) => {
    if (file.size > MAX_FILE_SIZE) {
      throw new Error(`File "${file.name}" is too large. Maximum size is 50MB.`);
    }
    
    const validTypes = ['application/pdf', 'image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/bmp'];
    if (!validTypes.some(type => file.type === type || file.name.toLowerCase().endsWith(type.split('/')[1]))) {
      throw new Error(`File "${file.name}" has an unsupported format.`);
    }
  };

  // State Management Functions
  const updateCounter = () => {
    const total = appState.uniquePLs.length;
    if (total === 0) {
      elements.counterEl.textContent = "No codes loaded";
      elements.counterEl.className = "counter pending";
    } else if (appState.scannedCount >= total) {
      elements.counterEl.textContent = `‚úÖ All ${total} codes scanned!`;
      elements.counterEl.className = "counter success";
    } else {
      elements.counterEl.textContent = `${appState.scannedCount} / ${total} codes scanned`;
      elements.counterEl.className = "counter pending";
    }
  };

  const updateClearBtnState = () => {
    elements.clearBtn.disabled = appState.uniquePLs.length === 0;
  };

  const updateSummaryBreakdown = () => {
    const total = appState.uniquePLs.length;
    const scanned = appState.scannedSet.size;
    const missing = total - scanned;
    const unmatched = appState.unmatchedList.length;

    if (total === 0) {
      elements.summaryBreakdown.textContent = "No data loaded";
      return;
    }

    elements.summaryBreakdown.innerHTML = `
      Total: ${total} | 
      <span style="color:#2f855a">‚úÖ Scanned: ${scanned}</span> | 
      <span style="color:#c53030">‚ùå Missing: ${missing}</span> | 
      <span style="color:#d69e2e">‚ö† Unmatched: ${unmatched}</span>
    `;
  };

  // Filtering and Search Functions
  const matchesFilter = (pl) => {
    const norm = normalize(pl);
    const isScanned = appState.scannedSet.has(norm);
    
    switch (appState.currentFilter) {
      case 'scanned': return isScanned;
      case 'pending': return !isScanned;
      default: return true;
    }
  };

  const matchesSearch = (pl) => {
    if (!appState.searchTerm) return true;
    return pl.toLowerCase().includes(appState.searchTerm.toLowerCase());
  };

  const getFilteredPLs = () => {
    return appState.uniquePLs.filter(pl => matchesFilter(pl) && matchesSearch(pl));
  };

  // Rendering Functions
  const renderTable = () => {
    elements.tableBody.innerHTML = "";
    appState.plRowMap.clear();

    if (appState.uniquePLs.length === 0) {
      elements.tableBody.innerHTML = `<tr><td colspan="4" style="text-align:center; padding:40px; color:#718096">Upload files to see PL codes here</td></tr>`;
      elements.totalCell.textContent = "Total: 0 codes";
      return;
    }

    const filteredPLs = getFilteredPLs();
    
    if (filteredPLs.length === 0) {
      elements.tableBody.innerHTML = `<tr><td colspan="4" style="text-align:center; padding:40px; color:#718096">No codes match current filters</td></tr>`;
      elements.totalCell.textContent = `Showing: 0 / ${appState.uniquePLs.length} codes`;
      return;
    }

    filteredPLs.forEach((pl, displayIndex) => {
      const actualIndex = appState.uniquePLs.indexOf(pl);
      const norm = normalize(pl);
      const isScanned = appState.scannedSet.has(norm);
      const tr = document.createElement("tr");
      
      tr.innerHTML = `
        <td>${actualIndex + 1}</td>
        <td><input type="checkbox" ${isScanned ? "checked" : ""} data-pl="${norm}"></td>
        <td style="font-family:monospace">${pl}</td>
        <td class="remark-cell">${isScanned ? "‚úÖ Scanned" : "‚ùå Not Scanned"}</td>
      `;

      if (isScanned) tr.classList.add("scanned");
      elements.tableBody.appendChild(tr);
      
      appState.plRowMap.set(norm, {
        row: tr,
        checkbox: tr.querySelector("input"),
        remarkCell: tr.querySelector(".remark-cell")
      });
    });

    elements.totalCell.textContent = `Showing: ${filteredPLs.length} / ${appState.uniquePLs.length} codes`;

    // Add checkbox event listeners
    elements.tableBody.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.addEventListener('change', (e) => {
        const pl = e.target.dataset.pl;
        const entry = appState.plRowMap.get(pl);
        
        if (e.target.checked && !appState.scannedSet.has(pl)) {
          onScanMatch(pl, "Manual Check");
        } else if (!e.target.checked && appState.scannedSet.has(pl)) {
          // Remove from scanned
          appState.scannedSet.delete(pl);
          appState.scannedCount--;
          entry.row.classList.remove("scanned");
          entry.remarkCell.textContent = "‚ùå Not Scanned";
          updateCounter();
          updateSummaryBreakdown();
        }
      });
    });
  };

  const renderUnmatched = () => {
    elements.unmatchedTable.innerHTML = "";

    if (appState.unmatchedList.length === 0) {
      elements.unmatchedTable.innerHTML = `<tr><td colspan="4" style="text-align:center; padding:40px; color:#718096">No unmatched codes</td></tr>`;
      return;
    }

    appState.unmatchedList.forEach((item, i) => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${i + 1}</td>
        <td style="font-family:monospace">${item.code}</td>
        <td>${item.source}</td>
        <td>${item.time}</td>
      `;
      elements.unmatchedTable.appendChild(tr);
    });
  };

  // Scanning Functions
  const onScanMatch = (rawCode, source = "Scanner") => {
    const code = normalize(rawCode);
    elements.lastScan.textContent = `Last: ${code}`;
    elements.lastScan.classList.remove("hidden");

    if (!PL_CANON.test(code)) {
      showStatus(elements.scanStatus, `‚ùå Invalid PL code: ${rawCode}`, "error");
      return;
    }

    const entry = appState.plRowMap.get(code);
    if (!entry) {
      // Check if it exists in the full list but is filtered out
      const exists = appState.uniquePLs.some(pl => normalize(pl) === code);
      if (exists) {
        showStatus(elements.scanStatus, `‚ö† Code filtered out, clearing filters...`, "warning");
        // Clear filters to show the code
        appState.currentFilter = 'all';
        appState.searchTerm = '';
        elements.searchInput.value = '';
        updateFilterButtons();
        renderTable();
        // Try again
        setTimeout(() => onScanMatch(rawCode, source), 100);
        return;
      }
      
      showStatus(elements.scanStatus, `‚ùå Code not in list: ${code}`, "error");
      appState.unmatchedList.push({
        code: code,
        source: source,
        time: new Date().toLocaleTimeString()
      });
      renderUnmatched();
      updateSummaryBreakdown();
      return;
    }

    if (appState.scannedSet.has(code)) {
      entry.remarkCell.textContent = "‚úÖ Already scanned";
      showStatus(elements.scanStatus, `‚ö† Already scanned: ${code}`, "warning");
      return;
    }

    appState.scannedSet.add(code);
    entry.checkbox.checked = true;
    entry.row.classList.add("scanned");
    entry.remarkCell.textContent = `‚úÖ Scanned at ${new Date().toLocaleTimeString()}`;
    appState.scannedCount++;

    updateCounter();
    showStatus(elements.scanStatus, `‚úÖ Matched: ${code}`, "success");
    updateSummaryBreakdown();
  };

  // File Processing Functions
  const sanitiseMatch = (raw) => {
    if (!raw) return null;
    const s = raw.replace(/\s+/g, "").replace(/[^A-Za-z0-9]/g, "").toUpperCase();
    return PL_CANON.test(s) ? s : null;
  };

  const findAndSanitiseAll = (text) => {
    const out = [];
    if (!text) return out;
    PL_FLEX_GLOBAL.lastIndex = 0;
    let m;
    while ((m = PL_FLEX_GLOBAL.exec(text)) !== null) {
      const san = sanitiseMatch(m[0]);
      if (san) out.push(san);
    }
    return out;
  };

  const extractPLsFromPDF = async (file) => {
    if (typeof pdfjsLib === 'undefined') {
      throw new Error('PDF.js library not loaded. Please check your internet connection and refresh the page.');
    }
    
    try {
      const data = new Uint8Array(await file.arrayBuffer());
      const pdf = await pdfjsLib.getDocument({ data }).promise;
      let found = [];

      for (let i = 1; i <= pdf.numPages; i++) {
        updateProgress((i / pdf.numPages) * 100);
        
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        
        // Look for PL codes in specific positions and generally
        const pageCandidates = [];
        textContent.items.forEach(t => {
          if (t.str && ((t.transform[4] >= PL_X_MIN && t.transform[4] <= PL_X_MAX && PL_FLEX.test(t.str)) || PL_FLEX.test(t.str))) {
            pageCandidates.push({ text: t.str, x: t.transform[4] });
          }
        });

        pageCandidates.forEach(c => {
          const san = sanitiseMatch(c.text);
          if (san) found.push(san);
        });

        // Also check the joined text
        const joined = textContent.items.map(it => it.str || '').join(" ");
        found.push(...findAndSanitiseAll(joined));
      }

      return found;
    } catch (error) {
      console.error('PDF extraction error:', error);
      throw new Error(`Failed to extract from PDF: ${error.message}`);
    }
  };

  const extractPLsFromImage = async (file) => {
    if (typeof Tesseract === 'undefined') {
      throw new Error('Tesseract.js library not loaded. Please check your internet connection and refresh the page.');
    }
    
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error('OCR processing timeout (30 seconds)'));
      }, 30000); // 30 second timeout

      Tesseract.recognize(file, "eng", {
        logger: (m) => {
          if (m.status === 'recognizing text') {
            updateProgress(m.progress * 100);
          }
        }
      }).then(({ data: { text } }) => {
        clearTimeout(timeoutId);
        resolve(findAndSanitiseAll(text));
      }).catch((error) => {
        clearTimeout(timeoutId);
        reject(new Error(`OCR failed: ${error.message}`));
      });
    });
  };

  const finalizePLs = (arr) => {
    const set = new Set();
    arr.forEach(c => set.add(normalize(c)));
    return Array.from(set).filter(c => PL_CANON.test(c)).sort();
  };

  // Filter Functions
  const updateFilterButtons = () => {
    document.querySelectorAll('[id^="filter"]').forEach(btn => {
      btn.style.backgroundColor = btn.id === `filter${appState.currentFilter.charAt(0).toUpperCase() + appState.currentFilter.slice(1)}` || 
                                  (btn.id === 'filterAll' && appState.currentFilter === 'all') ? '#3182ce' : '#718096';
    });
  };

  // Event Listeners
  elements.fileDropZone.addEventListener('click', () => elements.fileInput.click());

  // Drag and drop
  elements.fileDropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    elements.fileDropZone.classList.add('drag-over');
  });

  elements.fileDropZone.addEventListener('dragleave', () => {
    elements.fileDropZone.classList.remove('drag-over');
  });

  elements.fileDropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    elements.fileDropZone.classList.remove('drag-over');
    elements.fileInput.files = e.dataTransfer.files;
  });

  elements.barcodeInput.addEventListener("blur", () => 
    setTimeout(() => elements.barcodeInput.focus(), 200)
  );

  elements.barcodeInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      const val = elements.barcodeInput.value.trim();
      if (val) {
        onScanMatch(val, "Scanner");
        elements.barcodeInput.value = "";
      }
    }
  });

  // Manual entry
  elements.manualBtn.addEventListener("click", () => {
    elements.manualInput.value = "";
    elements.manualModal.classList.remove("hidden");
    setTimeout(() => elements.manualInput.focus(), 200);
  });

  elements.manualCancel.addEventListener("click", () => {
    elements.manualModal.classList.add("hidden");
  });

  elements.manualSubmit.addEventListener("click", () => {
    const val = elements.manualInput.value.trim();
    if (val) {
      elements.manualModal.classList.add("hidden");
      onScanMatch(val, "Manual");
    }
  });

  elements.manualInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      elements.manualSubmit.click();
    }
  });

  // Clear functionality
  elements.clearBtn.addEventListener("click", () => {
    elements.confirmModal.classList.remove("hidden");
  });

  elements.confirmYes.addEventListener("click", () => {
    appState.scannedSet.clear();
    appState.scannedCount = 0;
    appState.plRowMap.forEach((entry) => {
      entry.checkbox.checked = false;
      entry.row.classList.remove("scanned");
      entry.remarkCell.textContent = "‚ùå Not Scanned";
    });
    appState.unmatchedList = [];
    renderUnmatched();
    updateCounter();
    renderTable();
    elements.lastScan.classList.add("hidden");
    showStatus(elements.scanStatus, "üßπ All marks cleared", "info");
    elements.confirmModal.classList.add("hidden");
    updateSummaryBreakdown();
  });

  elements.confirmNo.addEventListener("click", () => {
    elements.confirmModal.classList.add("hidden");
  });

  // Search and filter
  const debouncedSearch = debounce(() => {
    appState.searchTerm = elements.searchInput.value.trim();
    renderTable();
  }, DEBOUNCE_DELAY);

  elements.searchInput.addEventListener("input", debouncedSearch);

  elements.filterAll.addEventListener("click", () => {
    appState.currentFilter = 'all';
    updateFilterButtons();
    renderTable();
  });

  elements.filterScanned.addEventListener("click", () => {
    appState.currentFilter = 'scanned';
    updateFilterButtons();
    renderTable();
  });

  elements.filterPending.addEventListener("click", () => {
    appState.currentFilter = 'pending';
    updateFilterButtons();
    renderTable();
  });

  // Download functionality
  elements.downloadBtn.addEventListener("click", () => {
    if (appState.uniquePLs.length === 0) {
      alert("‚ùå No PL codes to download");
      return;
    }

    try {
      let rows = [["PL Code", "Status", "Timestamp", "Index"]];

      appState.uniquePLs.forEach((pl, index) => {
        const norm = normalize(pl);
        const entry = appState.plRowMap.get(norm);
        let status = "‚ùå Not Scanned";
        let timestamp = "";

        if (appState.scannedSet.has(norm)) {
          status = "‚úÖ Scanned";
          const text = entry?.remarkCell?.textContent || "";
          const match = text.match(/at (.+)$/);
          if (match) timestamp = match[1];
        }

        rows.push([pl, status, timestamp, index + 1]);
      });

      // Add unmatched entries
      if (appState.unmatchedList.length > 0) {
        rows.push([]);
        rows.push(["=== UNMATCHED ENTRIES ==="]);
        appState.unmatchedList.forEach(u => {
          rows.push([u.code, `‚ö†Ô∏è Unmatched (${u.source})`, u.time, ""]);
        });
      }

      // Add summary
      rows.push([]);
      rows.push([
        "SUMMARY",
        `Total: ${appState.uniquePLs.length}`,
        `‚úÖ Scanned: ${appState.scannedSet.size}`,
        `‚ùå Missing: ${appState.uniquePLs.length - appState.scannedSet.size}`
      ]);
      rows.push([
        "",
        `‚ö† Unmatched: ${appState.unmatchedList.length}`,
        `Generated: ${new Date().toLocaleString()}`,
        ""
      ]);

      const csvContent = rows.map(r => r.map(f => `"${f}"`).join(",")).join("\n");
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `pl-codes-summary-${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      showStatus(elements.scanStatus, "‚úÖ Summary downloaded", "success");
    } catch (error) {
      console.error('Download error:', error);
      alert("‚ùå Error generating download");
    }
  });

  // Extract functionality with better error handling
  elements.extractBtn.addEventListener("click", async () => {
    if (appState.isProcessing) return;

    const files = Array.from(elements.fileInput.files);
    if (files.length === 0) {
      showStatus(elements.extractStatus, "‚ùå Please select files first", "error");
      return;
    }

    // Check if libraries are loaded
    const pdfOK = typeof pdfjsLib !== 'undefined';
    const ocrOK = typeof Tesseract !== 'undefined';
    
    const hasPDFs = files.some(f => f.type === 'application/pdf');
    const hasImages = files.some(f => f.type.startsWith('image/'));
    
    if (hasPDFs && !pdfOK) {
      showStatus(elements.extractStatus, "‚ùå PDF.js library failed to load. Please refresh the page.", "error");
      return;
    }
    
    if (hasImages && !ocrOK) {
      showStatus(elements.extractStatus, "‚ùå Tesseract.js library failed to load. Please refresh the page.", "error");
      return;
    }

    appState.isProcessing = true;
    elements.extractBtn.disabled = true;
    elements.extractBtn.textContent = "üîÑ Processing...";
    showStatus(elements.extractStatus, "Processing files...", "info");
    updateProgress(0);

    try {
      // Validate all files first
      for (const file of files) {
        validateFile(file);
      }

      let allCodes = [];
      let processedFiles = 0;
      let errorCount = 0;

      for (const file of files) {
        showStatus(elements.extractStatus, `Processing: ${file.name}`, "info");
        
        try {
          let codes = [];
          if (file.type === "application/pdf") {
            codes = await extractPLsFromPDF(file);
          } else if (file.type.startsWith("image/")) {
            codes = await extractPLsFromImage(file);
          }
          
          allCodes.push(...codes);
          processedFiles++;
        } catch (error) {
          console.error(`Error processing ${file.name}:`, error);
          errorCount++;
          showStatus(elements.extractStatus, `‚ö† Error in ${file.name}: ${error.message}`, "warning");
          
          // Continue processing other files
          await new Promise(resolve => setTimeout(resolve, 1000)); // Brief pause to show error
        }
      }

      // Finalize and update state
      appState.uniquePLs = finalizePLs(allCodes);
      appState.scannedSet.clear();
      appState.scannedCount = 0;
      appState.unmatchedList = [];
      appState.currentFilter = 'all';
      appState.searchTerm = '';
      elements.searchInput.value = '';

      // Update UI
      renderTable();
      renderUnmatched();
      updateCounter();
      updateClearBtnState();
      updateSummaryBreakdown();
      updateFilterButtons();

      updateProgress(0);
      
      let statusMessage = `‚úÖ Extracted ${appState.uniquePLs.length} unique codes`;
      if (errorCount > 0) {
        statusMessage += ` (${errorCount} files had errors)`;
      }
      
      showStatus(elements.extractStatus, statusMessage, errorCount > 0 ? "warning" : "success");
      showStatus(elements.scanStatus, "üéØ Ready to scan codes", "info");

    } catch (error) {
      console.error('Extraction error:', error);
      showStatus(elements.extractStatus, `‚ùå Error: ${error.message}`, "error");
      updateProgress(0);
    } finally {
      appState.isProcessing = false;
      elements.extractBtn.disabled = false;
      elements.extractBtn.textContent = "üîç Extract PL Codes";
    }
  });

  // Modal click outside to close
  [elements.confirmModal, elements.manualModal].forEach(modal => {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.classList.add('hidden');
      }
    });
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Escape to close modals
    if (e.key === 'Escape') {
      elements.confirmModal.classList.add('hidden');
      elements.manualModal.classList.add('hidden');
    }
    
    // Ctrl/Cmd + / to focus search
    if ((e.ctrlKey || e.metaKey) && e.key === '/') {
      e.preventDefault();
      elements.searchInput.focus();
    }
    
    // Ctrl/Cmd + Enter to focus barcode input
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      e.preventDefault();
      elements.barcodeInput.focus();
    }
  });

  // Initialize
  updateCounter();
  updateClearBtnState();
  updateSummaryBreakdown();
  updateFilterButtons();

  // Auto-focus barcode input when ready
  if (elements.barcodeInput) {
    elements.barcodeInput.focus();
  }

  // Offline status indicator
  const createOfflineIndicator = () => {
    const indicator = document.createElement('div');
    indicator.id = 'offlineIndicator';
    indicator.style.cssText = `
      position: fixed; top: 10px; right: 10px; z-index: 2000;
      padding: 8px 16px; border-radius: 20px; font-size: 14px;
      font-weight: 600; transition: all 0.3s ease;
      display: none;
    `;
    document.body.appendChild(indicator);
    return indicator;
  };

  const offlineIndicator = createOfflineIndicator();

  const updateOfflineStatus = () => {
    if (navigator.onLine) {
      offlineIndicator.style.display = 'none';
    } else {
      offlineIndicator.textContent = 'üì° Offline Mode';
      offlineIndicator.style.cssText += 'background: #fed7d7; color: #c53030; display: block;';
    }
  };

  // Check if external resources loaded successfully
  const checkResourcesLoaded = () => {
    const resourcesOK = typeof pdfjsLib !== 'undefined' && typeof Tesseract !== 'undefined';
    if (!resourcesOK && !navigator.onLine) {
      offlineIndicator.textContent = '‚ö†Ô∏è Limited Offline Mode - File processing unavailable';
      offlineIndicator.style.cssText += 'background: #fef5e7; color: #d69e2e; display: block;';
    }
    return resourcesOK;
  };

  // Network status listeners
  window.addEventListener('online', updateOfflineStatus);
  window.addEventListener('offline', updateOfflineStatus);
  
  // Initial check
  updateOfflineStatus();
  setTimeout(checkResourcesLoaded, 1000);

</script>
</body>
</html>
